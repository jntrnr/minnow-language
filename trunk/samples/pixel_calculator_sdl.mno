

feature Color
  r : double
  g : double
  b : double

  def Color(t_r:double, t_g:double, t_b:double)
    r = t_r
    g = t_g
    b = t_b
  end

  def Color()
    r = (0.0)
    g = (0.0)
    b = (0.0)
  end

end

feature Point
  x : int
  y : int

  def Point(t_x:int, t_y:int)
    x = t_x
    y = t_y
  end
end

feature Pixel
  color : Color
  point : Point

  def Pixel(t_point:Point, t_color:Color)
    color = t_color
    point = t_point
  end
end

//technically this should be an 'isolated actor' because of the use of SDL.delay
isolated actor SDLWriter

  m_width : int
  m_height : int

  m_x : int
  m_y : int
  m_pixels : int
  screen : SDL.Surface
  surface : SDL.Surface

  def SDLWriter(t_width:int, t_height:int)
    m_width = t_width
    m_height = t_height

    m_x = 0
    m_y = 0
    m_pixels = 0

    screen = new SDL.Surface()
    surface = new SDL.Surface()

    screen.create_main_window(t_width, t_height, 32)
    surface.create_surface(t_width, t_height, 32)
  end

  action AddPixel(p:Pixel)
    surface.draw_pixel((p.color.r * 255.0).to_int(), (p.color.g * 255.0).to_int(), (p.color.b * 255.0).to_int(), p.point.x, p.point.y)

    m_pixels += 1
    SDL.clear_events()

    if (p.point.x == m_width - 1)
      screen.blit_surface(surface)
    end


    if (m_pixels == (m_width * m_height))
      //Sys.exit()

      while(true)
        SDL.delay(100)
        SDL.clear_events()
      end

    end
  end
end

actor PixelCalc
  m_tl : Point
  m_br : Point
  m_sdl : SDLWriter
  m_width : int
  m_height : int

  def PixelCalc(tl:Point, br:Point, sdl:SDLWriter, t_width:int, t_height:int)
    m_tl = tl
    m_br = br
    m_sdl = sdl
    m_width = t_width
    m_height = t_height
  end

  def GetColor(xcoord:int, ycoord:int) : Color
    xscaled:double = xcoord.to_double()/(m_width.to_double()/3.0) - 2.0
    yscaled:double = ycoord.to_double()/(m_height.to_double()/3.0) - 1.5

    x:double = xscaled
    y:double = yscaled

    iteration:int = 0
    max_iteration:int = 768

    while ( (x*x) + (y*y) <= (2.0*2.0) && iteration < max_iteration )
      xtemp:double = (x*x) - (y*y) + xscaled
      y = (2.0*x*y) + yscaled
      x = xtemp
      iteration += 1
    end

    if (iteration == max_iteration)
      return new Color(0.0,0.0,0.0)
    else
      red:double = 0.0
      green:double = 0.0
      blue:double = 0.0
      iteration += 32
      if (iteration < 256)
        red = (iteration.to_double())/256.0
      elseif (iteration < 512)
        red = 1.0
        green = (iteration - 255).to_double()/256.0
      else
        red = 1.0
        green = 1.0
        blue = (iteration - 511).to_double()/256.0
      end

      return new Color(red, green, blue)
    end

  end

  action calc()
    y:int = m_tl.y
    while (y < m_br.y)
      x:int = m_tl.x
      while (x < m_br.x)
        m_sdl::AddPixel(new Pixel(new Point(x, y), GetColor(x,y)))
        x += 1
      end
      y += 1
    end
  end
end


action main(args : Array[string])
  w:int = 1024
  h:int = 1024
  sdlwriter:var = spawn SDLWriter(w, h)
  calcs:var = new Array[PixelCalc]
  x:int = 0
  y:int = 0

  div:int = 2

  while (x < w)
    y = 0
    while (y < h)
      p:var = spawn PixelCalc(new Point(x, y), new Point(x+(w/div), y+(h/div)), sdlwriter, w, h)
      p::calc()
      calcs.push(p)
      y += h/div
    end
    x += w/div
  end
end
